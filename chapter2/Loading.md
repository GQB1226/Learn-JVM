# 加载
***

在加载阶段，jvm需要完3件事情：
1. 通过类的全限定名来获取定义此类的二进制字节流。这里在虚拟机规范中没有明确指明从哪里来获取二进制字节流。可以在zip包读取（jar,war等），可以从网络获取，可以在运行时计算生成（动态代理），可以在其它文件生成（jsp）甚至可以在数据库中读取。
2. 将这个字节流所代表的静态存储结构转化为方法区运行时数据结构
3. 在内存中生成一个代表该类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

对于类的加载，尤其是上述的第一步，可以分为两种情况或者类型：非数组类和数组类。对于非数组类，开发人员可以选择使用系统提供的引导类加载器完成，也可以自定义类加载器（重写loadClass()方法）；对于数组类，数组类是由jvm直接创建的，但是数组类的元素类型（即数组去掉所有维度的类型）最终还是需要类加载器去创建，其中遵循以下规则：
	* 如果数组的组建类型（Component Type,数组去掉一个维度的类型）是引用类型，那么递归采用上面的过程加载这个组件类型
	* 如果数组的组建类型不是引用类型（eg,基本数据类型,int[] 数组）,jvm把这个数组标记为与引导类加载器关联
	* 数组类的可见性与组件类型的可见性是一致的。如果组件类型不是引用类型，那么数组类的可见性是public，意味着组件类型的可见性也是public。

***
****类加载器****

 顾名思义，类加载器是用来加载类的，但是类加载器的作用绝不仅仅是用于加载类。Java中的任意一个类，在Java虚拟机中都由一个类加载器和类本身确定其在虚拟机中的唯一性。当我们比较一个类与另外一个类是否相等的时候，往往是针对同一个类加载器的，如果两个除了类加载器之外其余的信息都是相同的，那么比较这两个类的实例是否是同一个实例返回的也是false的。所以如果不是同一个类加载器，比较是没有任何意义的。

从jvm角度，类加载器有两种：
	1. 启动类加载器。c++实现，是jvm自身的一部分
	2. 其它类加载器，独立于虚拟机，全部继承自抽象类java.lang.ClassLoader

从开发人员的角度，类加载器可以划分为三种：
	1. 启动类加载器
	2. 扩展类加载器
	3. 应用程序类加载器

学习类加载器，不得不提类加载器的[双亲委派模型](双亲委派模型.md)