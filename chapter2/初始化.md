# 初始化

类初始化是类加载过程的最后一步，本阶段才正真的开始执行类中定义的java程序代码
***
**虚拟机规范严格规定了有且只有5种情况必须对类立即进行初始化**
1. 遇到new,getstatic,putstatic,invokestatic这4条字节码指令的时候，如果类没有被初始化，则需要先初始化。生成上述4条指令最常见的java代码场景就是使用**new**关键字实例化对象的时候、读取或者设置一个类的静态字段的时候（被final修饰的，已经在编译期把结果放到常量池的除外）和调用一个类的静态方法的时候。
2. 使用反射机制对类进行反射调用的时候、
3. 初始化一个类，其父类还有进行初始化的时候，先初始化父类
4. 虚拟机启动时，虚拟机先初始化用户指定的主类（main()）
5. 使用jdk1.7及以上的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getstatic,REF_putStatic,REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有初始化，则需要先触发其初始化。

上述5中情形的行为称为对一个类的主动引用，除此之外，所有引用类的方式都不会触发初始化，称为被动引用。

***
在准备阶段，变量已经赋过一次初始值，该初始值是数据类型的默认初始值。在初始化阶段，则根据程序员编写的代码去初始化类变量和其它资源。
* 初始化阶段就是执行类构造器<\\clinit>()方法的过程。
* <\clinit>()方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的。
* 编译器收集的顺序由语句在源文件中出现的顺序决定
* 静态语句块只能访问到定义在静态语句块之前的变量，定义在之后的变量，**在前面的静态语句块可以赋值，但是不能访问**
* <\clinit>()不同于类的构造函数（<\init>()方法），它不需要显示的调用父类构造器，虚拟机会保证子类的<\clinit>()方法执行之前，父类的<\clinit>()方法已经执行完毕。因此，**虚拟机中第一个被执行的<\clinit>()方法肯定是java.lang.Object**
* 由于上条原因，父类中的静态语句块要优先于子类的变量赋值
* 接口中不能使用静态语句块，但任然有变量的赋值操作，因此接口和类一样都会生成<\clinit>()方法,但是不同于类，执行接口的<\clinit>()方法不会先执行父类的<\clinit>()方法，只有在父类接口中定义的变量使用时，父接口才会初始化。接口的实现类在初始化时也不会执行接口的</clinit>()方法
* <\clinit>()方法对类或者接口不是必需的
* jvm会保证一个类的<\clinit>()方法在多线程的环境中正确的加锁和同步


***
